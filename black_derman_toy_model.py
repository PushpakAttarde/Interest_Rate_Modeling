# -*- coding: utf-8 -*-
"""Black-Derman-Toy Model.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12__MLpmmJKgUpd7Clsbsszp8s0e67f40
"""

#Black-Derman-Toy Model
#Discrete Setup
#Binomial Model for Intertest Rate Modeling
#As per BDT, Volatility of interest rate is defined by sigma = 0.5 * log(r_u / r_d) at single node.
#Assumtions: i) Volatilities depend on time but not on state
#            ii) Volatility at a node in a given time period is the same as at any other node in that same period.

from sympy import symbols, solve, Eq, log
import builtins

input = builtins.input

def get_user_input():
    data = []
    for i in range(3):
        year = i + 1
        coupon_rate = float(input(f"Enter coupon rate for year {year}: "))
        volatility = float(input(f"Enter volatility for year {year}: "))
        data.append([year, coupon_rate, volatility])
    return data

# Get data from user
user_data = get_user_input()
print("User input data:")
for row in user_data:
    print(row)

par_value = 100
r_u, r_d = symbols('r_u r_d', real=True, positive=True)

initial_price_y1 = par_value /(1 + user_data[0][1])
initial_price_y2 = par_value /((1 + user_data[1][1])**2)
initial_price_y3 = par_value /((1 + user_data[2][1])**3)

#For 2 Year Maturity

eq1 = Eq((1 + user_data[0][1]), (0.5*(par_value/(1 + r_u)) + 0.5*(par_value/(1 + r_d))) / initial_price_y2)

#Using BDT
eq2 = Eq(user_data[1][2] , 0.5 * log(r_u / r_d))

solution = solve((eq1, eq2), (r_u, r_d))

r_u_value = solution[0][0]
r_d_value = solution[0][1]

B_u = par_value /(1 + r_u_value)
B_d = par_value /(1 + r_d_value)

print(f"Spot_rate(Up): {r_u_value:.4f}")
print(f"Spot_rate(Down): {r_d_value:.4f}")
print(f"Bond_price(Up): {B_u:.2f}")
print(f"Bond_price(Down): {B_d:.2f}")

#For 3 Year Maturity
from sympy import symbols, Eq, log, sqrt, nsolve

B_uu, B_ud, B_dd = symbols('B_uu B_ud B_dd', real=True, positive=True)

eq3 = Eq(initial_price_y3, (1/(1+user_data[0][1])) * 0.5 * ((0.5*B_uu + 0.5*B_ud) / (1+r_u_value) + (0.5*B_ud + 0.5*B_dd) / (1+r_d_value)))

eq4 = Eq(((par_value / B_ud) - 1) ** 2, (((par_value / B_uu) - 1) * ((par_value / B_dd) - 1)))

eq5 = Eq(user_data[2][2], 0.5 * log((sqrt(par_value / ((0.5*B_uu + 0.5*B_ud) / (1+r_u_value))) - 1) / (sqrt(par_value / ((0.5*B_ud + 0.5*B_dd) / (1+r_d_value))) - 1)))

# Refined initial guesses (tune these values)
initial_guess = (par_value * 0.90, par_value, par_value * 1.10)

# Use numerical solving (nsolve) with refined initial guess
sol = nsolve((eq3, eq4, eq5), (B_uu, B_ud, B_dd), initial_guess)

B_uu_value = sol[0]
B_ud_value = sol[1]
B_dd_value = sol[2]

r_uu_value = (par_value / B_uu_value) - 1
r_ud_value = (par_value / B_ud_value) - 1
r_dd_value = (par_value / B_dd_value) - 1

B_u_value = (0.5*B_uu_value + 0.5*B_ud_value) / (1+r_u_value)
B_d_value = (0.5*B_ud_value + 0.5*B_dd_value) / (1+r_d_value)

print(f"Spot_rate(Up_Up): {r_uu_value:.4f}")
print(f"Spot_rate(Up_Down): {r_ud_value:.4f}")
print(f"Spot_rate(Down_Down): {r_dd_value:.4f}")
print(f"B_uu_value: {B_uu_value:.2f}")
print(f"B_ud_value: {B_ud_value:.2f}")
print(f"B_dd_value: {B_dd_value:.2f}")
print(f"Spot_rate(Up): {r_u_value:.4f}")
print(f"Spot_rate(Down): {r_d_value:.4f}")
print(f"Bond_price(Up): {B_u_value:.2f}")
print(f"Bond_price(Down): {B_d_value:.2f}")
print(f"Initial_Bond_price: {initial_price_y3:.2f}")